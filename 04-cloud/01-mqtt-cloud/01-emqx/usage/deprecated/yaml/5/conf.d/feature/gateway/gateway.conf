gateway {
  ## @path gateway.stomp
  stomp {
    ## @path gateway.stomp.frame
    frame {
      ## @doc The maximum number of Header
      ## @path gateway.stomp.frame.max_headers
      ## @type non_neg_integer()
      ## @default 10
      max_headers = 10

      ## @doc The maximum string length of the Header Value
      ## @path gateway.stomp.frame.max_headers_length
      ## @type non_neg_integer()
      ## @default 1024
      max_headers_length = 1024

      ## @doc Maximum number of bytes of Body allowed per Stomp packet
      ## @path gateway.stomp.frame.max_body_length
      ## @type integer()
      ## @default 65536
      max_body_length = 65536
    }

    ## @doc
    ## @path gateway.stomp.mountpoint
    ## @type binary()
    ## @default ""
    mountpoint = ""

    ## @path gateway.stomp.listeners
    listeners {
      ## @doc
      ## @path gateway.stomp.listeners.tcp
      ## @type map_struct()
        #  tcp.name  =
        ## @path gateway.stomp.listeners.tcp.$name
        #   {
          ## @doc Size of the acceptor pool.
          ## @path gateway.stomp.listeners.tcp.$name.acceptors
          ## @type integer()
          ## @default 16
          #  acceptors = 16

          ## @path gateway.stomp.listeners.tcp.$name.tcp_options
          ## @link listeners.tcp.$name.tcp_options
          #  tcp_options {
            ## @doc Specify the {active, N} option for this Socket.</br>
            ## See: https://erlang.org/doc/man/inet.html#setopts-2
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.active_n
            ## @type integer()
            ## @default 100
            #  active_n = 100

            ## @doc TCP backlog defines the maximum length that the queue of
            ##  pending connections can grow to.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.backlog
            ## @type pos_integer()
            ## @default 1024
            #  backlog = 1024

            ## @doc The TCP send timeout for the connections.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.send_timeout
            ## @type emqx_schema:duration()
            ## @default 15s
            #  send_timeout = 15s

            ## @doc Close the connection if send timeout.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.send_timeout_close
            ## @type boolean()
            ## @default true
            #  send_timeout_close = true

            ## @doc The TCP receive buffer (OS kernel) for the connections.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.recbuf
            ## @type emqx_schema:bytesize()
            #  recbuf = 2KB

            ## @doc The TCP send buffer (OS kernel) for the connections.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.sndbuf
            ## @type emqx_schema:bytesize()
            #  sndbuf = 4KB

            ## @doc The size of the user-space buffer used by the driver.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.buffer
            ## @type emqx_schema:bytesize()
            ## @default 4KB
            #  buffer = 4KB

            ## @doc The socket is set to a busy state when the amount of data queued internally
            ##   by the VM socket implementation reaches this limit.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.high_watermark
            ## @type emqx_schema:bytesize()
            ## @default 1MB
            #  high_watermark = 1MB

            ## @doc The TCP_NODELAY flag for the connections.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.nodelay
            ## @type boolean()
            ## @default true
            #  nodelay = true

            ## @doc The SO_REUSEADDR flag for the connections.
            ## @path gateway.stomp.listeners.tcp.$name.tcp_options.reuseaddr
            ## @type boolean()
            ## @default true
            #  reuseaddr = true
          #   }

          ## @doc Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.
          ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
          ## @path gateway.stomp.listeners.tcp.$name.proxy_protocol
          ## @type boolean()
          ## @default false
          #  proxy_protocol = false

          ## @doc Timeout for proxy protocol.
          ## EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.
          ## @path gateway.stomp.listeners.tcp.$name.proxy_protocol_timeout
          ## @type emqx_gateway_schema:duration()
          ## @default 15s
          #  proxy_protocol_timeout = 15s

          ## @doc Enable the listener.
          ## @path gateway.stomp.listeners.tcp.$name.enable
          ## @type boolean()
          ## @default true
          #  enable = true

          ## @doc The IP address and port that the listener will bind.
          ## @path gateway.stomp.listeners.tcp.$name.bind
          ## @type union() emqx_gateway_schema:ip_port() | integer()
          #  bind  =

          ## @doc Maximum number of concurrent connections.
          ## @path gateway.stomp.listeners.tcp.$name.max_connections
          ## @type integer()
          ## @default 1024
          #  max_connections = 1024

          ## @doc Maximum connections per second.
          ## @path gateway.stomp.listeners.tcp.$name.max_conn_rate
          ## @type integer()
          ## @default 1000
          #  max_conn_rate = 1000

          ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
          ##  in listener configs
          ## @path gateway.stomp.listeners.tcp.$name.authentication
          ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
          #  authentication  =

          ## @doc Set <code>true</code> (default) to enable client authentication on this listener.
          ## When set to <code>false</code> clients will be allowed to connect without authentication.
          ## @path gateway.stomp.listeners.tcp.$name.enable_authn
          ## @type boolean()
          ## @default true
          #  enable_authn = true

          ## @doc When publishing or subscribing, prefix all topics with a mountpoint string.
          ## The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.
          ## For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `""` to disable the feature.
          ## Variables in mountpoint string:
          ##   - <code>${clientid}</code>: clientid
          ##   - <code>${username}</code>: username
          ## @path gateway.stomp.listeners.tcp.$name.mountpoint
          ## @type binary()
          #  mountpoint  =

          ## @doc The access control rules for this listener.
          ## See: https://github.com/emqtt/esockd#allowdeny
          ## @path gateway.stomp.listeners.tcp.$name.access_rules
          ## @type array()
          ## @default []
          #  access_rules = []
        #   }


      ## @doc
      ## @path gateway.stomp.listeners.ssl
      ## @type map_struct()
        #  ssl.name  =
        ## @path gateway.stomp.listeners.ssl.$name
        #   {
          ## @doc Size of the acceptor pool.
          ## @path gateway.stomp.listeners.ssl.$name.acceptors
          ## @type integer()
          ## @default 16
          #  acceptors = 16

          ## @path gateway.stomp.listeners.ssl.$name.tcp_options
          ## @link listeners.tcp.$name.tcp_options
          #  tcp_options {
            ## @doc Specify the {active, N} option for this Socket.</br>
            ## See: https://erlang.org/doc/man/inet.html#setopts-2
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.active_n
            ## @type integer()
            ## @default 100
            #  active_n = 100

            ## @doc TCP backlog defines the maximum length that the queue of
            ##  pending connections can grow to.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.backlog
            ## @type pos_integer()
            ## @default 1024
            #  backlog = 1024

            ## @doc The TCP send timeout for the connections.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.send_timeout
            ## @type emqx_schema:duration()
            ## @default 15s
            #  send_timeout = 15s

            ## @doc Close the connection if send timeout.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.send_timeout_close
            ## @type boolean()
            ## @default true
            #  send_timeout_close = true

            ## @doc The TCP receive buffer (OS kernel) for the connections.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.recbuf
            ## @type emqx_schema:bytesize()
            #  recbuf = 2KB

            ## @doc The TCP send buffer (OS kernel) for the connections.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.sndbuf
            ## @type emqx_schema:bytesize()
            #  sndbuf = 4KB

            ## @doc The size of the user-space buffer used by the driver.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.buffer
            ## @type emqx_schema:bytesize()
            ## @default 4KB
            #  buffer = 4KB

            ## @doc The socket is set to a busy state when the amount of data queued internally
            ##   by the VM socket implementation reaches this limit.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.high_watermark
            ## @type emqx_schema:bytesize()
            ## @default 1MB
            #  high_watermark = 1MB

            ## @doc The TCP_NODELAY flag for the connections.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.nodelay
            ## @type boolean()
            ## @default true
            #  nodelay = true

            ## @doc The SO_REUSEADDR flag for the connections.
            ## @path gateway.stomp.listeners.ssl.$name.tcp_options.reuseaddr
            ## @type boolean()
            ## @default true
            #  reuseaddr = true
          #   }

          ## @doc Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.
          ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
          ## @path gateway.stomp.listeners.ssl.$name.proxy_protocol
          ## @type boolean()
          ## @default false
          #  proxy_protocol = false

          ## @doc Timeout for proxy protocol.
          ## EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.
          ## @path gateway.stomp.listeners.ssl.$name.proxy_protocol_timeout
          ## @type emqx_gateway_schema:duration()
          ## @default 15s
          #  proxy_protocol_timeout = 15s

          ## @doc Enable the listener.
          ## @path gateway.stomp.listeners.ssl.$name.enable
          ## @type boolean()
          ## @default true
          #  enable = true

          ## @doc The IP address and port that the listener will bind.
          ## @path gateway.stomp.listeners.ssl.$name.bind
          ## @type union() emqx_gateway_schema:ip_port() | integer()
          #  bind  =

          ## @doc Maximum number of concurrent connections.
          ## @path gateway.stomp.listeners.ssl.$name.max_connections
          ## @type integer()
          ## @default 1024
          #  max_connections = 1024

          ## @doc Maximum connections per second.
          ## @path gateway.stomp.listeners.ssl.$name.max_conn_rate
          ## @type integer()
          ## @default 1000
          #  max_conn_rate = 1000

          ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
          ##  in listener configs
          ## @path gateway.stomp.listeners.ssl.$name.authentication
          ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
          ## @link gateway.stomp.listeners.tcp.$name.authentication
          #  authentication  =

          ## @doc Set <code>true</code> (default) to enable client authentication on this listener.
          ## When set to <code>false</code> clients will be allowed to connect without authentication.
          ## @path gateway.stomp.listeners.ssl.$name.enable_authn
          ## @type boolean()
          ## @default true
          #  enable_authn = true

          ## @doc When publishing or subscribing, prefix all topics with a mountpoint string.
          ## The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.
          ## For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `""` to disable the feature.
          ## Variables in mountpoint string:
          ##   - <code>${clientid}</code>: clientid
          ##   - <code>${username}</code>: username
          ## @path gateway.stomp.listeners.ssl.$name.mountpoint
          ## @type binary()
          #  mountpoint  =

          ## @doc The access control rules for this listener.
          ## See: https://github.com/emqtt/esockd#allowdeny
          ## @path gateway.stomp.listeners.ssl.$name.access_rules
          ## @type array()
          ## @default []
          #  access_rules = []

          ## @path gateway.stomp.listeners.ssl.$name.ssl_options
          ## @link listeners.ssl.$name.ssl_options
          #  ssl_options {
            ## @doc Trusted PEM format CA certificates bundle file.</br>
            ## The certificates in this file are used to verify the TLS peer's certificates.
            ## Append new certificates to the file if new CAs are to be trusted.
            ## There is no need to restart EMQX to have the updated file loaded, because
            ## the system regularly checks if file has been updated (and reload).</br>
            ## NOTE: invalidating (deleting) a certificate from the file will not affect
            ## already established connections.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.cacertfile
            ## @type binary()
            #  cacertfile  =

            ## @doc PEM format certificates chain file.</br>
            ## The certificates in this file should be in reversed order of the certificate
            ## issue chain. That is, the host's certificate should be placed in the beginning
            ## of the file, followed by the immediate issuer certificate and so on.
            ## Although the root CA certificate is optional, it should be placed at the end of
            ## the file if it is to be added.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.certfile
            ## @type binary()
            #  certfile  =

            ## @doc PEM format private key file.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.keyfile
            ## @type binary()
            #  keyfile  =

            ## @doc Enable or disable peer verification.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.verify
            ## @type enum: verify_peer | verify_none
            ## @default verify_none
            #  verify = verify_none

            ## @doc Enable TLS session reuse.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.reuse_sessions
            ## @type boolean()
            ## @default true
            #  reuse_sessions = true

            ## @doc Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.depth
            ## @type integer()
            ## @default 10
            #  depth = 10

            ## @doc String containing the user's password.
            ## Only used if the private key file is password-protected.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.password
            ## @type string()
            #  password = ""

            ## @doc All TLS/DTLS versions to be supported.</br>
            ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>
            ## In case PSK cipher suites are intended, make sure to configured
            ## <code>['tlsv1.2', 'tlsv1.1']</code> here.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.versions
            ## @type array()
            ## @default [tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]
            #  versions = [tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]

            ## @doc This config holds TLS cipher suite names separated by comma,
            ## or as an array of strings. e.g.
            ## <code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
            ## <code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
            ## </br>
            ## Ciphers (and their ordering) define the way in which the
            ## client and server encrypts information over the network connection.
            ## Selecting a good cipher suite is critical for the
            ## application's data security, confidentiality and performance.
            ##
            ## The names should be in OpenSSL string format (not RFC format).
            ## All default values and examples provided by EMQX config
            ## documentation are all in OpenSSL format.</br>
            ##
            ## NOTE: Certain cipher suites are only compatible with
            ## specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
            ## incompatible cipher suites will be silently dropped.
            ## For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
            ## configuring cipher suites for other versions will have no effect.
            ## </br>
            ##
            ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>
            ## If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>
            ## PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
            ## RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
            ## RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
            ## RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.ciphers
            ## @type array()
            ## @default ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256", "TLS_CHACHA20_POLY1305_SHA256", "TLS_AES_128_CCM_SHA256", "TLS_AES_128_CCM_8_SHA256", "ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]
            #  ciphers = ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256", "TLS_CHACHA20_POLY1305_SHA256", "TLS_AES_128_CCM_SHA256", "TLS_AES_128_CCM_8_SHA256", "ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]

            ## @doc EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.user_lookup_fun
            ## @type string()
            ## @default "emqx_tls_psk:lookup"
            #  user_lookup_fun = "emqx_tls_psk:lookup"

            ## @doc SSL parameter renegotiation is a feature that allows a client and a server
            ## to renegotiate the parameters of the SSL connection on the fly.
            ## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
            ## you drop support for the insecure renegotiation, prone to MitM attacks.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.secure_renegotiate
            ## @type boolean()
            ## @default true
            #  secure_renegotiate = true

            ## @doc Path to a file containing PEM-encoded Diffie-Hellman parameters
            ## to be used by the server if a cipher suite using Diffie-Hellman
            ## key exchange is negotiated. If not specified, default parameters
            ## are used.</br>
            ## NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.dhfile
            ## @type string()
            #  dhfile  =

            ## @doc Used together with {verify, verify_peer} by an TLS/DTLS server.
            ## If set to true, the server fails if the client does not have a
            ## certificate to send, that is, sends an empty certificate.
            ## If set to false, it fails only if the client sends an invalid
            ## certificate (an empty certificate is considered valid).
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.fail_if_no_peer_cert
            ## @type boolean()
            ## @default false
            #  fail_if_no_peer_cert = false

            ## @doc An important security setting, it forces the cipher to be set based
            ##  on the server-specified order instead of the client-specified order,
            ##  hence enforcing the (usually more properly configured) security
            ##  ordering of the server administrator.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.honor_cipher_order
            ## @type boolean()
            ## @default true
            #  honor_cipher_order = true

            ## @doc In protocols that support client-initiated renegotiation,
            ## the cost of resources of such an operation is higher for the server than the client.
            ## This can act as a vector for denial of service attacks.
            ## The SSL application already takes measures to counter-act such attempts,
            ## but client-initiated renegotiation can be strictly disabled by setting this option to false.
            ## The default value is true. Note that disabling renegotiation can result in
            ## long-lived connections becoming unusable due to limits on
            ## the number of messages the underlying cipher suite can encipher.
            ## @path gateway.stomp.listeners.ssl.$name.ssl_options.client_renegotiation
            ## @type boolean()
            ## @default true
            #  client_renegotiation = true
          #   }
        #   }

     }

    ## @doc Whether to enable this gateway
    ## @path gateway.stomp.enable
    ## @type boolean()
    ## @default true
    enable = true

    ## @doc Whether to enable client process statistic
    ## @path gateway.stomp.enable_stats
    ## @type boolean()
    ## @default true
    enable_stats = true

    ## @doc The idle time of the client connection process. It has two purposes:
    ##   1. A newly created client process that does not receive any client requests after that time will be closed directly.
    ##   2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.
    ## @path gateway.stomp.idle_timeout
    ## @type emqx_gateway_schema:duration()
    ## @default 30s
    idle_timeout = 30s

    ## @path gateway.stomp.clientinfo_override
    clientinfo_override {
      ## @doc Template for overriding username.
      ## @path gateway.stomp.clientinfo_override.username
      ## @type binary()
      #  username  =

      ## @doc Template for overriding password.
      ## @path gateway.stomp.clientinfo_override.password
      ## @type binary()
      #  password  =

      ## @doc Template for overriding clientid.
      ## @path gateway.stomp.clientinfo_override.clientid
      ## @type binary()
      #  clientid  =
     }

    ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
    ##  in listener configs
    ## @path gateway.stomp.authentication
    ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
    ## @link gateway.stomp.listeners.tcp.$name.authentication
    #  authentication  =
   }

  ## @path gateway.mqttsn
  mqttsn {
    ## @doc MQTT-SN Gateway ID.
    ## When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value
    ## @path gateway.mqttsn.gateway_id
    ## @type integer()
    ## @default 1
    gateway_id = 1

    ## @doc Whether to periodically broadcast ADVERTISE messages
    ## @path gateway.mqttsn.broadcast
    ## @type boolean()
    ## @default false
    broadcast = false

    ## @doc Allows connectionless clients to publish messages with a Qos of -1.
    ## This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW
    ## @path gateway.mqttsn.enable_qos3
    ## @type boolean()
    ## @default true
    enable_qos3 = true

    ## @doc Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel
    ## @path gateway.mqttsn.subs_resume
    ## @type boolean()
    ## @default false
    subs_resume = false

    ## @doc The pre-defined topic IDs and topic names.
    ## A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway
    ## @path gateway.mqttsn.predefined
    ## @type array()
    ## @default []
    predefined = []

    ## @doc
    ## @path gateway.mqttsn.mountpoint
    ## @type binary()
    ## @default ""
    mountpoint = ""

    ## @path gateway.mqttsn.listeners
    listeners {
      ## @doc
      ## @path gateway.mqttsn.listeners.udp
      ## @type map_struct()
        #  udp.name  =
        ## @path gateway.mqttsn.listeners.udp.$name
        #   {
          ## @path gateway.mqttsn.listeners.udp.$name.udp_options
          #  udp_options {
            ## @doc Specify the {active, N} option for the socket.
            ## See: https://erlang.org/doc/man/inet.html#setopts-2
            ## @path gateway.mqttsn.listeners.udp.$name.udp_options.active_n
            ## @type integer()
            ## @default 100
            #  active_n = 100

            ## @doc Size of the kernel-space receive buffer for the socket.
            ## @path gateway.mqttsn.listeners.udp.$name.udp_options.recbuf
            ## @type emqx_gateway_schema:bytesize()
            #  recbuf  =

            ## @doc Size of the kernel-space send buffer for the socket.
            ## @path gateway.mqttsn.listeners.udp.$name.udp_options.sndbuf
            ## @type emqx_gateway_schema:bytesize()
            #  sndbuf  =

            ## @doc Size of the user-space buffer for the socket.
            ## @path gateway.mqttsn.listeners.udp.$name.udp_options.buffer
            ## @type emqx_gateway_schema:bytesize()
            #  buffer  =

            ## @doc Allow local reuse of port numbers.
            ## @path gateway.mqttsn.listeners.udp.$name.udp_options.reuseaddr
            ## @type boolean()
            ## @default true
            #  reuseaddr = true
          #   }

          ## @doc Enable the listener.
          ## @path gateway.mqttsn.listeners.udp.$name.enable
          ## @type boolean()
          ## @default true
          #  enable = true

          ## @doc The IP address and port that the listener will bind.
          ## @path gateway.mqttsn.listeners.udp.$name.bind
          ## @type union() emqx_gateway_schema:ip_port() | integer()
          #  bind  =

          ## @doc Maximum number of concurrent connections.
          ## @path gateway.mqttsn.listeners.udp.$name.max_connections
          ## @type integer()
          ## @default 1024
          #  max_connections = 1024

          ## @doc Maximum connections per second.
          ## @path gateway.mqttsn.listeners.udp.$name.max_conn_rate
          ## @type integer()
          ## @default 1000
          #  max_conn_rate = 1000

          ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
          ##  in listener configs
          ## @path gateway.mqttsn.listeners.udp.$name.authentication
          ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
          ## @link gateway.stomp.listeners.tcp.$name.authentication
          #  authentication  =

          ## @doc Set <code>true</code> (default) to enable client authentication on this listener.
          ## When set to <code>false</code> clients will be allowed to connect without authentication.
          ## @path gateway.mqttsn.listeners.udp.$name.enable_authn
          ## @type boolean()
          ## @default true
          #  enable_authn = true

          ## @doc When publishing or subscribing, prefix all topics with a mountpoint string.
          ## The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.
          ## For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `""` to disable the feature.
          ## Variables in mountpoint string:
          ##   - <code>${clientid}</code>: clientid
          ##   - <code>${username}</code>: username
          ## @path gateway.mqttsn.listeners.udp.$name.mountpoint
          ## @type binary()
          #  mountpoint  =

          ## @doc The access control rules for this listener.
          ## See: https://github.com/emqtt/esockd#allowdeny
          ## @path gateway.mqttsn.listeners.udp.$name.access_rules
          ## @type array()
          ## @default []
          #  access_rules = []
        #   }


      ## @doc
      ## @path gateway.mqttsn.listeners.dtls
      ## @type map_struct()
        #  dtls.name  =
        ## @path gateway.mqttsn.listeners.dtls.$name
        #   {
          ## @doc Size of the acceptor pool.
          ## @path gateway.mqttsn.listeners.dtls.$name.acceptors
          ## @type integer()
          ## @default 16
          #  acceptors = 16

          ## @path gateway.mqttsn.listeners.dtls.$name.udp_options
          ## @link gateway.mqttsn.listeners.udp.$name.udp_options
          #  udp_options {
            ## @doc Specify the {active, N} option for the socket.
            ## See: https://erlang.org/doc/man/inet.html#setopts-2
            ## @path gateway.mqttsn.listeners.dtls.$name.udp_options.active_n
            ## @type integer()
            ## @default 100
            #  active_n = 100

            ## @doc Size of the kernel-space receive buffer for the socket.
            ## @path gateway.mqttsn.listeners.dtls.$name.udp_options.recbuf
            ## @type emqx_gateway_schema:bytesize()
            #  recbuf  =

            ## @doc Size of the kernel-space send buffer for the socket.
            ## @path gateway.mqttsn.listeners.dtls.$name.udp_options.sndbuf
            ## @type emqx_gateway_schema:bytesize()
            #  sndbuf  =

            ## @doc Size of the user-space buffer for the socket.
            ## @path gateway.mqttsn.listeners.dtls.$name.udp_options.buffer
            ## @type emqx_gateway_schema:bytesize()
            #  buffer  =

            ## @doc Allow local reuse of port numbers.
            ## @path gateway.mqttsn.listeners.dtls.$name.udp_options.reuseaddr
            ## @type boolean()
            ## @default true
            #  reuseaddr = true
          #   }

          ## @doc Enable the listener.
          ## @path gateway.mqttsn.listeners.dtls.$name.enable
          ## @type boolean()
          ## @default true
          #  enable = true

          ## @doc The IP address and port that the listener will bind.
          ## @path gateway.mqttsn.listeners.dtls.$name.bind
          ## @type union() emqx_gateway_schema:ip_port() | integer()
          #  bind  =

          ## @doc Maximum number of concurrent connections.
          ## @path gateway.mqttsn.listeners.dtls.$name.max_connections
          ## @type integer()
          ## @default 1024
          #  max_connections = 1024

          ## @doc Maximum connections per second.
          ## @path gateway.mqttsn.listeners.dtls.$name.max_conn_rate
          ## @type integer()
          ## @default 1000
          #  max_conn_rate = 1000

          ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
          ##  in listener configs
          ## @path gateway.mqttsn.listeners.dtls.$name.authentication
          ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
          ## @link gateway.stomp.listeners.tcp.$name.authentication
          #  authentication  =

          ## @doc Set <code>true</code> (default) to enable client authentication on this listener.
          ## When set to <code>false</code> clients will be allowed to connect without authentication.
          ## @path gateway.mqttsn.listeners.dtls.$name.enable_authn
          ## @type boolean()
          ## @default true
          #  enable_authn = true

          ## @doc When publishing or subscribing, prefix all topics with a mountpoint string.
          ## The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.
          ## For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `""` to disable the feature.
          ## Variables in mountpoint string:
          ##   - <code>${clientid}</code>: clientid
          ##   - <code>${username}</code>: username
          ## @path gateway.mqttsn.listeners.dtls.$name.mountpoint
          ## @type binary()
          #  mountpoint  =

          ## @doc The access control rules for this listener.
          ## See: https://github.com/emqtt/esockd#allowdeny
          ## @path gateway.mqttsn.listeners.dtls.$name.access_rules
          ## @type array()
          ## @default []
          #  access_rules = []

          ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options
          #  dtls_options {
            ## @doc Trusted PEM format CA certificates bundle file.</br>
            ## The certificates in this file are used to verify the TLS peer's certificates.
            ## Append new certificates to the file if new CAs are to be trusted.
            ## There is no need to restart EMQX to have the updated file loaded, because
            ## the system regularly checks if file has been updated (and reload).</br>
            ## NOTE: invalidating (deleting) a certificate from the file will not affect
            ## already established connections.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.cacertfile
            ## @type binary()
            #  cacertfile  =

            ## @doc PEM format certificates chain file.</br>
            ## The certificates in this file should be in reversed order of the certificate
            ## issue chain. That is, the host's certificate should be placed in the beginning
            ## of the file, followed by the immediate issuer certificate and so on.
            ## Although the root CA certificate is optional, it should be placed at the end of
            ## the file if it is to be added.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.certfile
            ## @type binary()
            #  certfile  =

            ## @doc PEM format private key file.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.keyfile
            ## @type binary()
            #  keyfile  =

            ## @doc Enable or disable peer verification.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.verify
            ## @type enum: verify_peer | verify_none
            ## @default verify_none
            #  verify = verify_none

            ## @doc Enable TLS session reuse.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.reuse_sessions
            ## @type boolean()
            ## @default true
            #  reuse_sessions = true

            ## @doc Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.depth
            ## @type integer()
            ## @default 10
            #  depth = 10

            ## @doc String containing the user's password.
            ## Only used if the private key file is password-protected.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.password
            ## @type string()
            #  password = ""

            ## @doc All TLS/DTLS versions to be supported.</br>
            ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>
            ## In case PSK cipher suites are intended, make sure to configured
            ## <code>['tlsv1.2', 'tlsv1.1']</code> here.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.versions
            ## @type array()
            ## @default [dtlsv1.2, dtlsv1]
            #  versions = [dtlsv1.2, dtlsv1]

            ## @doc This config holds TLS cipher suite names separated by comma,
            ## or as an array of strings. e.g.
            ## <code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
            ## <code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
            ## </br>
            ## Ciphers (and their ordering) define the way in which the
            ## client and server encrypts information over the network connection.
            ## Selecting a good cipher suite is critical for the
            ## application's data security, confidentiality and performance.
            ##
            ## The names should be in OpenSSL string format (not RFC format).
            ## All default values and examples provided by EMQX config
            ## documentation are all in OpenSSL format.</br>
            ##
            ## NOTE: Certain cipher suites are only compatible with
            ## specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
            ## incompatible cipher suites will be silently dropped.
            ## For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
            ## configuring cipher suites for other versions will have no effect.
            ## </br>
            ##
            ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>
            ## If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>
            ## PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
            ## RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
            ## RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
            ## RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.ciphers
            ## @type array()
            ## @default ["ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]
            #  ciphers = ["ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]

            ## @doc EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.user_lookup_fun
            ## @type string()
            ## @default "emqx_tls_psk:lookup"
            #  user_lookup_fun = "emqx_tls_psk:lookup"

            ## @doc SSL parameter renegotiation is a feature that allows a client and a server
            ## to renegotiate the parameters of the SSL connection on the fly.
            ## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
            ## you drop support for the insecure renegotiation, prone to MitM attacks.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.secure_renegotiate
            ## @type boolean()
            ## @default true
            #  secure_renegotiate = true

            ## @doc Path to a file containing PEM-encoded Diffie-Hellman parameters
            ## to be used by the server if a cipher suite using Diffie-Hellman
            ## key exchange is negotiated. If not specified, default parameters
            ## are used.</br>
            ## NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.dhfile
            ## @type string()
            #  dhfile  =

            ## @doc Used together with {verify, verify_peer} by an TLS/DTLS server.
            ## If set to true, the server fails if the client does not have a
            ## certificate to send, that is, sends an empty certificate.
            ## If set to false, it fails only if the client sends an invalid
            ## certificate (an empty certificate is considered valid).
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.fail_if_no_peer_cert
            ## @type boolean()
            ## @default false
            #  fail_if_no_peer_cert = false

            ## @doc An important security setting, it forces the cipher to be set based
            ##  on the server-specified order instead of the client-specified order,
            ##  hence enforcing the (usually more properly configured) security
            ##  ordering of the server administrator.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.honor_cipher_order
            ## @type boolean()
            ## @default true
            #  honor_cipher_order = true

            ## @doc In protocols that support client-initiated renegotiation,
            ## the cost of resources of such an operation is higher for the server than the client.
            ## This can act as a vector for denial of service attacks.
            ## The SSL application already takes measures to counter-act such attempts,
            ## but client-initiated renegotiation can be strictly disabled by setting this option to false.
            ## The default value is true. Note that disabling renegotiation can result in
            ## long-lived connections becoming unusable due to limits on
            ## the number of messages the underlying cipher suite can encipher.
            ## @path gateway.mqttsn.listeners.dtls.$name.dtls_options.client_renegotiation
            ## @type boolean()
            ## @default true
            #  client_renegotiation = true
          #   }
        #   }

     }

    ## @doc Whether to enable this gateway
    ## @path gateway.mqttsn.enable
    ## @type boolean()
    ## @default true
    enable = true

    ## @doc Whether to enable client process statistic
    ## @path gateway.mqttsn.enable_stats
    ## @type boolean()
    ## @default true
    enable_stats = true

    ## @doc The idle time of the client connection process. It has two purposes:
    ##   1. A newly created client process that does not receive any client requests after that time will be closed directly.
    ##   2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.
    ## @path gateway.mqttsn.idle_timeout
    ## @type emqx_gateway_schema:duration()
    ## @default 30s
    idle_timeout = 30s

    ## @path gateway.mqttsn.clientinfo_override
    ## @link gateway.stomp.clientinfo_override
    clientinfo_override {
      ## @doc Template for overriding username.
      ## @path gateway.mqttsn.clientinfo_override.username
      ## @type binary()
      #  username  =

      ## @doc Template for overriding password.
      ## @path gateway.mqttsn.clientinfo_override.password
      ## @type binary()
      #  password  =

      ## @doc Template for overriding clientid.
      ## @path gateway.mqttsn.clientinfo_override.clientid
      ## @type binary()
      #  clientid  =
     }

    ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
    ##  in listener configs
    ## @path gateway.mqttsn.authentication
    ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
    ## @link gateway.stomp.listeners.tcp.$name.authentication
    #  authentication  =
   }

  ## @path gateway.coap
  coap {
    ## @doc The gateway server required minimum heartbeat interval.
    ## When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive
    ## @path gateway.coap.heartbeat
    ## @type emqx_gateway_schema:duration()
    ## @default 30s
    heartbeat = 30s

    ## @doc Enable or disable connection mode.
    ## Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources
    ## @path gateway.coap.connection_required
    ## @type boolean()
    ## @default false
    connection_required = false

    ## @doc The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.
    ## The type of delivered coap message can be set to:
    ##   - non: Non-confirmable;
    ##   - con: Confirmable;
    ##   - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con
    ## @path gateway.coap.notify_type
    ## @type enum: non | con | qos
    ## @default qos
    notify_type = qos

    ## @doc The Default QoS Level indicator for subscribe request.
    ## This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:
    ##   - qos0, qos1, qos2: Fixed default QoS level
    ##   - coap: Dynamic QoS level by the message type of subscribe request
    ##     * qos0: If the subscribe request is non-confirmable
    ##     * qos1: If the subscribe request is confirmable
    ## @path gateway.coap.subscribe_qos
    ## @type enum: qos0 | qos1 | qos2 | coap
    ## @default coap
    subscribe_qos = coap

    ## @doc The Default QoS Level indicator for publish request.
    ## This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:
    ##   - qos0, qos1, qos2: Fixed default QoS level
    ##   - coap: Dynamic QoS level by the message type of publish request
    ##     * qos0: If the publish request is non-confirmable
    ##     * qos1: If the publish request is confirmable
    ## @path gateway.coap.publish_qos
    ## @type enum: qos0 | qos1 | qos2 | coap
    ## @default coap
    publish_qos = coap

    ## @doc
    ## @path gateway.coap.mountpoint
    ## @type binary()
    ## @default ""
    mountpoint = ""

    ## @path gateway.coap.listeners
    ## @link gateway.mqttsn.listeners
    listeners {
      ## @doc
      ## @path gateway.coap.listeners.udp
      ## @type map_struct()
      ## @link gateway.mqttsn.listeners.udp.$name


      ## @doc
      ## @path gateway.coap.listeners.dtls
      ## @type map_struct()
      ## @link gateway.mqttsn.listeners.dtls.$name

     }

    ## @doc Whether to enable this gateway
    ## @path gateway.coap.enable
    ## @type boolean()
    ## @default true
    enable = true

    ## @doc Whether to enable client process statistic
    ## @path gateway.coap.enable_stats
    ## @type boolean()
    ## @default true
    enable_stats = true

    ## @doc The idle time of the client connection process. It has two purposes:
    ##   1. A newly created client process that does not receive any client requests after that time will be closed directly.
    ##   2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.
    ## @path gateway.coap.idle_timeout
    ## @type emqx_gateway_schema:duration()
    ## @default 30s
    idle_timeout = 30s

    ## @path gateway.coap.clientinfo_override
    ## @link gateway.stomp.clientinfo_override
    clientinfo_override {
      ## @doc Template for overriding username.
      ## @path gateway.coap.clientinfo_override.username
      ## @type binary()
      #  username  =

      ## @doc Template for overriding password.
      ## @path gateway.coap.clientinfo_override.password
      ## @type binary()
      #  password  =

      ## @doc Template for overriding clientid.
      ## @path gateway.coap.clientinfo_override.clientid
      ## @type binary()
      #  clientid  =
     }

    ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
    ##  in listener configs
    ## @path gateway.coap.authentication
    ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
    ## @link gateway.stomp.listeners.tcp.$name.authentication
    #  authentication  =
   }

  ## @path gateway.lwm2m
  lwm2m {
    ## @doc The Directory for LwM2M Resource definition
    ## @path gateway.lwm2m.xml_dir
    ## @type binary()
    ## @default "etc/lwm2m_xml"
    xml_dir = "etc/lwm2m_xml"

    ## @doc Minimum value of lifetime allowed to be set by the LwM2M client
    ## @path gateway.lwm2m.lifetime_min
    ## @type emqx_gateway_schema:duration()
    ## @default 15s
    lifetime_min = 15s

    ## @doc Maximum value of lifetime allowed to be set by the LwM2M client
    ## @path gateway.lwm2m.lifetime_max
    ## @type emqx_gateway_schema:duration()
    ## @default 86400s
    lifetime_max = 86400s

    ## @doc The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.
    ## For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory.
    ## @path gateway.lwm2m.qmode_time_window
    ## @type emqx_gateway_schema:duration_s()
    ## @default 22s
    qmode_time_window = 22s

    ## @doc Automatically observe the object list of REGISTER packet
    ## @path gateway.lwm2m.auto_observe
    ## @type boolean()
    ## @default false
    auto_observe = false

    ## @doc Policy for publishing UPDATE event message.
    ##   - always: send update events as long as the UPDATE request is received.
    ##   - contains_object_list: send update events only if the UPDATE request carries any Object List
    ## @path gateway.lwm2m.update_msg_publish_condition
    ## @type enum: always | contains_object_list
    ## @default contains_object_list
    update_msg_publish_condition = contains_object_list

    ## @path gateway.lwm2m.translators
    translators {
      ## @path gateway.lwm2m.translators.command
      command {
        ## @doc Topic Name
        ## @path gateway.lwm2m.translators.command.topic
        ## @type binary()
        #  topic  =

        ## @doc QoS Level
        ## @path gateway.lwm2m.translators.command.qos
        ## @type qos()
        ## @default 0
        qos = 0
       }

      ## @path gateway.lwm2m.translators.response
      ## @link gateway.lwm2m.translators.command
      response {
        ## @doc Topic Name
        ## @path gateway.lwm2m.translators.response.topic
        ## @type binary()
        #  topic  =

        ## @doc QoS Level
        ## @path gateway.lwm2m.translators.response.qos
        ## @type qos()
        ## @default 0
        qos = 0
       }

      ## @path gateway.lwm2m.translators.notify
      ## @link gateway.lwm2m.translators.command
      notify {
        ## @doc Topic Name
        ## @path gateway.lwm2m.translators.notify.topic
        ## @type binary()
        #  topic  =

        ## @doc QoS Level
        ## @path gateway.lwm2m.translators.notify.qos
        ## @type qos()
        ## @default 0
        qos = 0
       }

      ## @path gateway.lwm2m.translators.register
      ## @link gateway.lwm2m.translators.command
      register {
        ## @doc Topic Name
        ## @path gateway.lwm2m.translators.register.topic
        ## @type binary()
        #  topic  =

        ## @doc QoS Level
        ## @path gateway.lwm2m.translators.register.qos
        ## @type qos()
        ## @default 0
        qos = 0
       }

      ## @path gateway.lwm2m.translators.update
      ## @link gateway.lwm2m.translators.command
      update {
        ## @doc Topic Name
        ## @path gateway.lwm2m.translators.update.topic
        ## @type binary()
        #  topic  =

        ## @doc QoS Level
        ## @path gateway.lwm2m.translators.update.qos
        ## @type qos()
        ## @default 0
        qos = 0
       }
     }

    ## @doc
    ## @path gateway.lwm2m.mountpoint
    ## @type binary()
    ## @default "lwm2m/${endpoint_name}/"
    mountpoint = "lwm2m/${endpoint_name}/"

    ## @path gateway.lwm2m.listeners
    ## @link gateway.mqttsn.listeners
    listeners {
      ## @doc
      ## @path gateway.lwm2m.listeners.udp
      ## @type map_struct()
      ## @link gateway.mqttsn.listeners.udp.$name


      ## @doc
      ## @path gateway.lwm2m.listeners.dtls
      ## @type map_struct()
      ## @link gateway.mqttsn.listeners.dtls.$name

     }

    ## @doc Whether to enable this gateway
    ## @path gateway.lwm2m.enable
    ## @type boolean()
    ## @default true
    enable = true

    ## @doc Whether to enable client process statistic
    ## @path gateway.lwm2m.enable_stats
    ## @type boolean()
    ## @default true
    enable_stats = true

    ## @doc The idle time of the client connection process. It has two purposes:
    ##   1. A newly created client process that does not receive any client requests after that time will be closed directly.
    ##   2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.
    ## @path gateway.lwm2m.idle_timeout
    ## @type emqx_gateway_schema:duration()
    ## @default 30s
    idle_timeout = 30s

    ## @path gateway.lwm2m.clientinfo_override
    ## @link gateway.stomp.clientinfo_override
    clientinfo_override {
      ## @doc Template for overriding username.
      ## @path gateway.lwm2m.clientinfo_override.username
      ## @type binary()
      #  username  =

      ## @doc Template for overriding password.
      ## @path gateway.lwm2m.clientinfo_override.password
      ## @type binary()
      #  password  =

      ## @doc Template for overriding clientid.
      ## @path gateway.lwm2m.clientinfo_override.clientid
      ## @type binary()
      #  clientid  =
     }

    ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
    ##  in listener configs
    ## @path gateway.lwm2m.authentication
    ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
    ## @link gateway.stomp.listeners.tcp.$name.authentication
    #  authentication  =
   }

  ## @path gateway.exproto
  exproto {
    ## @path gateway.exproto.server
    server {
      ## @doc Listening address and port for the gRPC server.
      ## @path gateway.exproto.server.bind
      ## @type union() emqx_gateway_schema:ip_port() | integer()
      #  bind  =

      ## @path gateway.exproto.server.ssl_options
      ssl_options {
        ## @doc Trusted PEM format CA certificates bundle file.</br>
        ## The certificates in this file are used to verify the TLS peer's certificates.
        ## Append new certificates to the file if new CAs are to be trusted.
        ## There is no need to restart EMQX to have the updated file loaded, because
        ## the system regularly checks if file has been updated (and reload).</br>
        ## NOTE: invalidating (deleting) a certificate from the file will not affect
        ## already established connections.
        ## @path gateway.exproto.server.ssl_options.cacertfile
        ## @type binary()
        #  cacertfile  =

        ## @doc PEM format certificates chain file.</br>
        ## The certificates in this file should be in reversed order of the certificate
        ## issue chain. That is, the host's certificate should be placed in the beginning
        ## of the file, followed by the immediate issuer certificate and so on.
        ## Although the root CA certificate is optional, it should be placed at the end of
        ## the file if it is to be added.
        ## @path gateway.exproto.server.ssl_options.certfile
        ## @type binary()
        #  certfile  =

        ## @doc PEM format private key file.
        ## @path gateway.exproto.server.ssl_options.keyfile
        ## @type binary()
        #  keyfile  =

        ## @doc Enable or disable peer verification.
        ## @path gateway.exproto.server.ssl_options.verify
        ## @type enum: verify_peer | verify_none
        ## @default verify_none
        verify = verify_none

        ## @doc Enable TLS session reuse.
        ## @path gateway.exproto.server.ssl_options.reuse_sessions
        ## @type boolean()
        ## @default true
        reuse_sessions = true

        ## @doc Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.
        ## @path gateway.exproto.server.ssl_options.depth
        ## @type integer()
        ## @default 10
        depth = 10

        ## @doc String containing the user's password.
        ## Only used if the private key file is password-protected.
        ## @path gateway.exproto.server.ssl_options.password
        ## @type string()
        password = ""

        ## @doc All TLS/DTLS versions to be supported.</br>
        ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>
        ## In case PSK cipher suites are intended, make sure to configured
        ## <code>['tlsv1.2', 'tlsv1.1']</code> here.
        ## @path gateway.exproto.server.ssl_options.versions
        ## @type array()
        ## @default [tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]
        versions = [tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]

        ## @doc This config holds TLS cipher suite names separated by comma,
        ## or as an array of strings. e.g.
        ## <code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
        ## <code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
        ## </br>
        ## Ciphers (and their ordering) define the way in which the
        ## client and server encrypts information over the network connection.
        ## Selecting a good cipher suite is critical for the
        ## application's data security, confidentiality and performance.
        ##
        ## The names should be in OpenSSL string format (not RFC format).
        ## All default values and examples provided by EMQX config
        ## documentation are all in OpenSSL format.</br>
        ##
        ## NOTE: Certain cipher suites are only compatible with
        ## specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
        ## incompatible cipher suites will be silently dropped.
        ## For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
        ## configuring cipher suites for other versions will have no effect.
        ## </br>
        ##
        ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>
        ## If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>
        ## PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
        ## RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
        ## RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
        ## RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>
        ## @path gateway.exproto.server.ssl_options.ciphers
        ## @type array()
        ## @default ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256", "TLS_CHACHA20_POLY1305_SHA256", "TLS_AES_128_CCM_SHA256", "TLS_AES_128_CCM_8_SHA256", "ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]
        ciphers = ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256", "TLS_CHACHA20_POLY1305_SHA256", "TLS_AES_128_CCM_SHA256", "TLS_AES_128_CCM_8_SHA256", "ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]

        ## @doc EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.
        ## @path gateway.exproto.server.ssl_options.user_lookup_fun
        ## @type string()
        ## @default "emqx_tls_psk:lookup"
        user_lookup_fun = "emqx_tls_psk:lookup"

        ## @doc SSL parameter renegotiation is a feature that allows a client and a server
        ## to renegotiate the parameters of the SSL connection on the fly.
        ## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
        ## you drop support for the insecure renegotiation, prone to MitM attacks.
        ## @path gateway.exproto.server.ssl_options.secure_renegotiate
        ## @type boolean()
        ## @default true
        secure_renegotiate = true

        ## @doc Path to a file containing PEM-encoded Diffie-Hellman parameters
        ## to be used by the server if a cipher suite using Diffie-Hellman
        ## key exchange is negotiated. If not specified, default parameters
        ## are used.</br>
        ## NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.
        ## @path gateway.exproto.server.ssl_options.dhfile
        ## @type string()
        #  dhfile  =

        ## @doc Used together with {verify, verify_peer} by an TLS/DTLS server.
        ## If set to true, the server fails if the client does not have a
        ## certificate to send, that is, sends an empty certificate.
        ## If set to false, it fails only if the client sends an invalid
        ## certificate (an empty certificate is considered valid).
        ## @path gateway.exproto.server.ssl_options.fail_if_no_peer_cert
        ## @type boolean()
        ## @default false
        fail_if_no_peer_cert = false

        ## @doc An important security setting, it forces the cipher to be set based
        ##  on the server-specified order instead of the client-specified order,
        ##  hence enforcing the (usually more properly configured) security
        ##  ordering of the server administrator.
        ## @path gateway.exproto.server.ssl_options.honor_cipher_order
        ## @type boolean()
        ## @default true
        honor_cipher_order = true

        ## @doc In protocols that support client-initiated renegotiation,
        ## the cost of resources of such an operation is higher for the server than the client.
        ## This can act as a vector for denial of service attacks.
        ## The SSL application already takes measures to counter-act such attempts,
        ## but client-initiated renegotiation can be strictly disabled by setting this option to false.
        ## The default value is true. Note that disabling renegotiation can result in
        ## long-lived connections becoming unusable due to limits on
        ## the number of messages the underlying cipher suite can encipher.
        ## @path gateway.exproto.server.ssl_options.client_renegotiation
        ## @type boolean()
        ## @default true
        client_renegotiation = true

        ## @doc Maximum time duration allowed for the handshake to complete
        ## @path gateway.exproto.server.ssl_options.handshake_timeout
        ## @type emqx_schema:duration()
        ## @default 15s
        handshake_timeout = 15s
       }
     }

    ## @path gateway.exproto.handler
    handler {
      ## @doc gRPC server address.
      ## @path gateway.exproto.handler.address
      ## @type binary()
      #  address  =

      ## @path gateway.exproto.handler.ssl_options
      ## @link cluster.etcd.ssl
      ssl_options {
        ## @doc Trusted PEM format CA certificates bundle file.</br>
        ## The certificates in this file are used to verify the TLS peer's certificates.
        ## Append new certificates to the file if new CAs are to be trusted.
        ## There is no need to restart EMQX to have the updated file loaded, because
        ## the system regularly checks if file has been updated (and reload).</br>
        ## NOTE: invalidating (deleting) a certificate from the file will not affect
        ## already established connections.
        ## @path gateway.exproto.handler.ssl_options.cacertfile
        ## @type binary()
        #  cacertfile  =

        ## @doc PEM format certificates chain file.</br>
        ## The certificates in this file should be in reversed order of the certificate
        ## issue chain. That is, the host's certificate should be placed in the beginning
        ## of the file, followed by the immediate issuer certificate and so on.
        ## Although the root CA certificate is optional, it should be placed at the end of
        ## the file if it is to be added.
        ## @path gateway.exproto.handler.ssl_options.certfile
        ## @type binary()
        #  certfile  =

        ## @doc PEM format private key file.
        ## @path gateway.exproto.handler.ssl_options.keyfile
        ## @type binary()
        #  keyfile  =

        ## @doc Enable or disable peer verification.
        ## @path gateway.exproto.handler.ssl_options.verify
        ## @type enum: verify_peer | verify_none
        ## @default verify_none
        verify = verify_none

        ## @doc Enable TLS session reuse.
        ## @path gateway.exproto.handler.ssl_options.reuse_sessions
        ## @type boolean()
        ## @default true
        reuse_sessions = true

        ## @doc Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.
        ## @path gateway.exproto.handler.ssl_options.depth
        ## @type integer()
        ## @default 10
        depth = 10

        ## @doc String containing the user's password.
        ## Only used if the private key file is password-protected.
        ## @path gateway.exproto.handler.ssl_options.password
        ## @type string()
        password = ""

        ## @doc All TLS/DTLS versions to be supported.</br>
        ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>
        ## In case PSK cipher suites are intended, make sure to configured
        ## <code>['tlsv1.2', 'tlsv1.1']</code> here.
        ## @path gateway.exproto.handler.ssl_options.versions
        ## @type array()
        ## @default [tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]
        versions = [tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]

        ## @doc This config holds TLS cipher suite names separated by comma,
        ## or as an array of strings. e.g.
        ## <code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
        ## <code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
        ## </br>
        ## Ciphers (and their ordering) define the way in which the
        ## client and server encrypts information over the network connection.
        ## Selecting a good cipher suite is critical for the
        ## application's data security, confidentiality and performance.
        ##
        ## The names should be in OpenSSL string format (not RFC format).
        ## All default values and examples provided by EMQX config
        ## documentation are all in OpenSSL format.</br>
        ##
        ## NOTE: Certain cipher suites are only compatible with
        ## specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
        ## incompatible cipher suites will be silently dropped.
        ## For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
        ## configuring cipher suites for other versions will have no effect.
        ## </br>
        ##
        ## NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>
        ## If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>
        ## PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
        ## RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
        ## RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
        ## RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code></br>
        ## @path gateway.exproto.handler.ssl_options.ciphers
        ## @type array()
        ## @default ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256", "TLS_CHACHA20_POLY1305_SHA256", "TLS_AES_128_CCM_SHA256", "TLS_AES_128_CCM_8_SHA256", "ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]
        ciphers = ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256", "TLS_CHACHA20_POLY1305_SHA256", "TLS_AES_128_CCM_SHA256", "TLS_AES_128_CCM_8_SHA256", "ECDHE-ECDSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-ECDSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDH-ECDSA-AES256-GCM-SHA384", "ECDH-RSA-AES256-GCM-SHA384", "ECDH-ECDSA-AES256-SHA384", "ECDH-RSA-AES256-SHA384", "DHE-DSS-AES256-GCM-SHA384", "DHE-DSS-AES256-SHA256", "AES256-GCM-SHA384", "AES256-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDH-ECDSA-AES128-GCM-SHA256", "ECDH-RSA-AES128-GCM-SHA256", "ECDH-ECDSA-AES128-SHA256", "ECDH-RSA-AES128-SHA256", "DHE-DSS-AES128-GCM-SHA256", "DHE-DSS-AES128-SHA256", "AES128-GCM-SHA256", "AES128-SHA256", "ECDHE-ECDSA-AES256-SHA", "ECDHE-RSA-AES256-SHA", "DHE-DSS-AES256-SHA", "ECDH-ECDSA-AES256-SHA", "ECDH-RSA-AES256-SHA", "ECDHE-ECDSA-AES128-SHA", "ECDHE-RSA-AES128-SHA", "DHE-DSS-AES128-SHA", "ECDH-ECDSA-AES128-SHA", "ECDH-RSA-AES128-SHA", "RSA-PSK-AES256-GCM-SHA384", "RSA-PSK-AES256-CBC-SHA384", "RSA-PSK-AES128-GCM-SHA256", "RSA-PSK-AES128-CBC-SHA256", "RSA-PSK-AES256-CBC-SHA", "RSA-PSK-AES128-CBC-SHA"]

        ## @doc EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.
        ## @path gateway.exproto.handler.ssl_options.user_lookup_fun
        ## @type string()
        ## @default "emqx_tls_psk:lookup"
        user_lookup_fun = "emqx_tls_psk:lookup"

        ## @doc SSL parameter renegotiation is a feature that allows a client and a server
        ## to renegotiate the parameters of the SSL connection on the fly.
        ## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
        ## you drop support for the insecure renegotiation, prone to MitM attacks.
        ## @path gateway.exproto.handler.ssl_options.secure_renegotiate
        ## @type boolean()
        ## @default true
        secure_renegotiate = true

        ## @doc Enable TLS.
        ## @path gateway.exproto.handler.ssl_options.enable
        ## @type boolean()
        ## @default false
        enable = false

        ## @doc Specify the host name to be used in TLS Server Name Indication extension.</br>
        ## For instance, when connecting to "server.example.net", the genuine server
        ## which accepts the connection and performs TLS handshake may differ from the
        ## host the TLS client initially connects to, e.g. when connecting to an IP address
        ## or when the host has multiple resolvable DNS records </br>
        ## If not specified, it will default to the host name string which is used
        ## to establish the connection, unless it is IP addressed used.</br>
        ## The host name is then also used in the host name verification of the peer
        ## certificate.</br> The special value 'disable' prevents the Server Name
        ## Indication extension from being sent and disables the hostname
        ## verification check.
        ## @path gateway.exproto.handler.ssl_options.server_name_indication
        ## @type union() disable | string()
        server_name_indication = disable
       }
     }

    ## @doc
    ## @path gateway.exproto.mountpoint
    ## @type binary()
    ## @default ""
    mountpoint = ""

    ## @path gateway.exproto.listeners
    listeners {
      ## @doc
      ## @path gateway.exproto.listeners.tcp
      ## @type map_struct()
      ## @link gateway.stomp.listeners.tcp.$name


      ## @doc
      ## @path gateway.exproto.listeners.ssl
      ## @type map_struct()
      ## @link gateway.stomp.listeners.ssl.$name


      ## @doc
      ## @path gateway.exproto.listeners.udp
      ## @type map_struct()
      ## @link gateway.mqttsn.listeners.udp.$name


      ## @doc
      ## @path gateway.exproto.listeners.dtls
      ## @type map_struct()
      ## @link gateway.mqttsn.listeners.dtls.$name

     }

    ## @doc Whether to enable this gateway
    ## @path gateway.exproto.enable
    ## @type boolean()
    ## @default true
    enable = true

    ## @doc Whether to enable client process statistic
    ## @path gateway.exproto.enable_stats
    ## @type boolean()
    ## @default true
    enable_stats = true

    ## @doc The idle time of the client connection process. It has two purposes:
    ##   1. A newly created client process that does not receive any client requests after that time will be closed directly.
    ##   2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.
    ## @path gateway.exproto.idle_timeout
    ## @type emqx_gateway_schema:duration()
    ## @default 30s
    idle_timeout = 30s

    ## @path gateway.exproto.clientinfo_override
    ## @link gateway.stomp.clientinfo_override
    clientinfo_override {
      ## @doc Template for overriding username.
      ## @path gateway.exproto.clientinfo_override.username
      ## @type binary()
      #  username  =

      ## @doc Template for overriding password.
      ## @path gateway.exproto.clientinfo_override.password
      ## @type binary()
      #  password  =

      ## @doc Template for overriding clientid.
      ## @path gateway.exproto.clientinfo_override.clientid
      ## @type binary()
      #  clientid  =
     }

    ## @doc Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
    ##  in listener configs
    ## @path gateway.exproto.authentication
    ## @type union() authn-builtin_db:authentication | authn-mysql:authentication | authn-postgresql:authentication | authn-mongodb:standalone | authn-mongodb:replica-set | authn-mongodb:sharded-cluster | authn-redis:standalone | authn-redis:cluster | authn-redis:sentinel | authn-http:get | authn-http:post | authn-jwt:hmac-based | authn-jwt:public-key | authn-jwt:jwks | authn-scram-builtin_db:authentication
    ## @link gateway.stomp.listeners.tcp.$name.authentication
    #  authentication  =
   }
 }
